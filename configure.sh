#!/bin/bash
# Copyright 2020 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
set -euo pipefail

PLATFORM="$(uname -s | tr 'A-Z' 'a-z')"


# --- helpers ---------------------------------------------------------------
write_bazelrc()      { echo "$1" >> .bazelrc; }
write_tf_rc()        { echo "$1" >> .tf_configure.bazelrc; }
die() { echo "ERROR: $*" >&2; exit 1; }

is_macos()    { [[ "${PLATFORM}" == "darwin" ]]; }
is_windows()  { [[ "${PLATFORM}" =~ msys_nt*|mingw*|cygwin*|uwin* ]]; }

write_legacy_python_repo() {
  mkdir -p third_party/python_legacy

  # empty WORKSPACE
  cat > third_party/python_legacy/WORKSPACE <<'EOF'
# intentionally empty
EOF

  # simple BUILD that exports defs.bzl
  cat > third_party/python_legacy/BUILD <<'EOF'
package(default_visibility = ["//visibility:public"])
exports_files(["defs.bzl"])
EOF

  # defs.bzl MUST define 'interpreter' as a string, not a function.
  # We also export py_runtime to satisfy older loads.
  cat > third_party/python_legacy/defs.bzl <<EOF
# AUTOGENERATED by configure.sh
load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")
# Absolute path to the python interpreter Bazel/TF should use:
interpreter = "${PYTHON_BIN_PATH}"
py_runtime = native.py_runtime
EOF

  echo "Wrote third_party/python_legacy with interpreter=${PYTHON_BIN_PATH}"
}

# --- start fresh -----------------------------------------------------------
rm -f .bazelrc .tf_configure.bazelrc

# --- parse args ------------------------------------------------------------
USER_PY=""
for arg in "$@"; do
  case "$arg" in
    --python=*) USER_PY="${arg#--python=}" ;;
    *) echo "Unknown arg: $arg" ;;
  esac
done

# --- choose interpreter (venv/conda/system) --------------------------------
if [[ -n "${USER_PY}" ]]; then
  PY="$USER_PY"
elif [[ -n "${PYTHON_BIN_PATH:-}" ]]; then
  PY="$PYTHON_BIN_PATH"
elif [[ -n "${CONDA_PREFIX:-}" && -x "${CONDA_PREFIX}/bin/python" ]]; then
  PY="${CONDA_PREFIX}/bin/python"
elif command -v python3.11 >/dev/null 2>&1; then
  PY="$(command -v python3.11)"
elif command -v python3 >/dev/null 2>&1; then
  PY="$(command -v python3)"
else
  die "No suitable Python found. Pass --python=/path/to/python or set PYTHON_BIN_PATH."
fi

# Normalize to an absolute path (readlink -f is GNU; fall back to python)
if command -v readlink >/dev/null 2>&1; then
  PY_ABS="$(readlink -f "$PY" 2>/dev/null || true)"
fi
if [[ -z "${PY_ABS:-}" ]]; then
  PY_ABS="$("$PY" - <<'PY'
import os,sys
print(os.path.abspath(sys.executable))
PY
)"
fi
PYTHON_BIN_PATH="$PY_ABS"

# --- choose CPU/GPU like upstream script (default CPU) ---------------------
TF_NEED_CUDA=""
while [[ -z "${TF_NEED_CUDA}" ]]; do
  read -p "Build against TensorFlow CPU pip package? [Y/n] " INPUT || true
  case "${INPUT:-Y}" in
    [Yy]* ) echo "CPU build selected."; TF_NEED_CUDA=0;;
    [Nn]* ) echo "GPU build selected."; TF_NEED_CUDA=1;;
    * ) echo "Please answer Y or n.";;
  esac
done

# For TF >= 2.1 this value isn’t actually consulted by TFQ,
# but we keep a compatible prompt/flag.
TF_CUDA_VERSION="11"

# --- sanity: python is importable and has TF -------------------------------
if [[ ! -x "$PYTHON_BIN_PATH" ]]; then
  die "$PYTHON_BIN_PATH not found/executable."
fi

# Ensure TF is importable from system python (user should have installed it).
"$PYTHON_BIN_PATH" - <<'PY' || { echo "ERROR: tensorflow not importable by chosen Python."; exit 1; }
import tensorflow as tf
import tensorflow.sysconfig as sc
print("TF:", tf.__version__)
print("include:", sc.get_include())
print("lib:", sc.get_lib())
PY

# --- discover TF include/lib robustly --------------------------------------
HDR="$("$PYTHON_BIN_PATH" - <<'PY'
import tensorflow.sysconfig as sc
print(sc.get_include())
PY
)"

LIBDIR="$("$PYTHON_BIN_PATH" - <<'PY'
import os, tensorflow.sysconfig as sc
p = sc.get_lib()
print(p if os.path.isdir(p) else os.path.dirname(p))
PY
)"

LIBNAME="$("$PYTHON_BIN_PATH" - <<'PY'
import os, glob, tensorflow.sysconfig as sc
p = sc.get_lib()
d = p if os.path.isdir(p) else os.path.dirname(p)
cands = glob.glob(os.path.join(d,'libtensorflow_framework.so*')) \
     or glob.glob(os.path.join(d,'libtensorflow.so*')) \
     or glob.glob(os.path.join(d,'_pywrap_tensorflow_internal.*'))
print(os.path.basename(cands[0]) if cands else 'libtensorflow_framework.so.2')
PY
)"

echo "Detected:"
echo "  PYTHON_BIN_PATH=$PYTHON_BIN_PATH"
echo "  TF_HEADER_DIR=$HDR"
echo "  TF_SHARED_LIBRARY_DIR=$LIBDIR"
echo "  TF_SHARED_LIBRARY_NAME=$LIBNAME"

# --- write .tf_configure.bazelrc (repo_env for repository rules) -----------
write_tf_rc "build --repo_env=PYTHON_BIN_PATH=$PYTHON_BIN_PATH"
write_tf_rc "build --repo_env=TF_HEADER_DIR=$HDR"
write_tf_rc "build --repo_env=TF_SHARED_LIBRARY_DIR=$LIBDIR"
write_tf_rc "build --repo_env=TF_SHARED_LIBRARY_NAME=$LIBNAME"
write_tf_rc "build --repo_env=TF_NEED_CUDA=$TF_NEED_CUDA"
write_tf_rc "build --repo_env=TF_CUDA_VERSION=$TF_CUDA_VERSION"

# Make sure repo rules and sub-config see legacy Keras (keras 2 instead of Keras 3)
write_tf_rc "build --repo_env=TF_USE_LEGACY_KERAS=1"

# --- write third_party/python_legacy/ with interpreter --------------------
write_legacy_python_repo

# --- write .bazelrc (imports TF config  usual flags) -----------------
write_bazelrc "try-import %workspace%/.tf_configure.bazelrc"
write_bazelrc "build --experimental_repo_remote_exec"
write_bazelrc "build --spawn_strategy=standalone"
write_bazelrc "build --strategy=Genrule=standalone"
write_bazelrc "build -c opt"
write_bazelrc "build --cxxopt=\"-D_GLIBCXX_USE_CXX11_ABI=1\""
write_bazelrc "build --cxxopt=\"-std=c++17\""
write_bazelrc "build --action_env=PYTHON_BIN_PATH=$PYTHON_BIN_PATH"
write_bazelrc "build --action_env=TF_USE_LEGACY_KERAS=1"
write_bazelrc "test  --action_env=TF_USE_LEGACY_KERAS=1"


# zlib / protobuf warning suppressions
write_bazelrc "build --per_file_copt=external/.*@-Wno-deprecated-non-prototype"
write_bazelrc "build --host_per_file_copt=external/.*@-Wno-deprecated-non-prototype"
write_bazelrc "build --per_file_copt=external/com_google_protobuf/.*@-Wno-unused-function"
write_bazelrc "build --host_per_file_copt=external/com_google_protobuf/.*@-Wno-unused-function"

# qsim warnings
# The following supress warnings coming from qsim.
# TODO: fix the code in qsim & update TFQ to use the updated version.
write_bazelrc "build --per_file_copt=tensorflow_quantum/core/ops/noise/tfq_.*@-Wno-unused-but-set-variable"
write_bazelrc "build --host_per_file_copt=tensorflow_quantum/core/ops/noise/tfq_.*@-Wno-unused-but-set-variable"
write_bazelrc "build --per_file_copt=tensorflow_quantum/core/ops/math_ops/tfq_.*@-Wno-deprecated-declarations"
write_bazelrc "build --host_per_file_copt=tensorflow_quantum/core/ops/math_ops/tfq_.*@-Wno-deprecated-declarations"


# rpath so the dynamic linker finds TF’s shared lib
if ! is_windows; then
  write_bazelrc "build --linkopt=-Wl,-rpath,${LIBDIR}"
fi

# CUDA toggle
if [[ "$TF_NEED_CUDA" == "1" ]]; then
  write_bazelrc "build:cuda --define=using_cuda=true --define=using_cuda_nvcc=true"
  write_bazelrc "build:cuda --@local_config_cuda//:enable_cuda"
  write_bazelrc "build:cuda --crosstool_top=@local_config_cuda//crosstool:toolchain"
  if is_windows; then
    write_tf_rc "build --repo_env=CUDNN_INSTALL_PATH=C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v${TF_CUDA_VERSION}"
    write_tf_rc "build --repo_env=CUDA_TOOLKIT_PATH=C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v${TF_CUDA_VERSION}"
  else
    write_tf_rc "build --repo_env=CUDNN_INSTALL_PATH=/usr/lib/x86_64-linux-gnu"
    write_tf_rc "build --repo_env=CUDA_TOOLKIT_PATH=/usr/local/cuda"
  fi
  write_bazelrc "build --config=cuda"
  write_bazelrc "test --config=cuda"
fi

echo
echo "Wrote .tf_configure.bazelrc and .bazelrc successfully."
